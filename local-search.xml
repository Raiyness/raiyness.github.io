<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Monotonic Stack</title>
    <link href="/2024/09/05/Monotonic%20Stack/"/>
    <url>/2024/09/05/Monotonic%20Stack/</url>
    
    <content type="html"><![CDATA[<p>单调栈，一种特殊的栈数据结构</p><span id="more"></span><h2 id="什么是单调栈？">什么是<strong>单调栈</strong>？</h2><p>单调栈，是一种特殊的栈数据结构。在这种栈中，元素始终保持单调递增或单调递减的顺序。当我们插入一个新元素时，会先弹出栈顶的所有不满足单调性的元素，然后再将新元素压入栈中。</p><p><img src="https://raw.githubusercontent.com/Raiyness/picgo/master/rayPicGo/Monotonic_Stack.gif" alt=""></p><h2 id="单调栈的类型">单调栈的类型</h2><h3 id="单调递增栈">单调递增栈</h3><p>栈中的每个元素比其下方的元素要大。每当新元素进栈时，如果栈顶元素比当前元素大或相等，则将栈顶元素出栈，直到栈顶元素小于新元素或栈为空。</p><h4 id="伪代码">伪代码</h4><div class="pseudocode">\begin{algorithm}\caption{Monotonic Stack for Finding the Next Greater Element}\begin{algorithmic}  \Procedure{NextGreaterElement}{$nums$}    \State $stack \gets \emptyset$ \Comment{Initialize an empty stack}    \State $result \gets$ array of size $|nums|$ filled with $-1$    \Comment{Initialize result array with -1}<pre><code class="hljs">\For&#123;$i \gets 0$ \To $|nums| - 1$&#125;  \While&#123;$stack$ is not empty and $nums[stack.top()] &lt; nums[i]$&#125;    \State $index \gets stack.pop()$    \State $result[index] \gets nums[i]$  \EndWhile  \State $stack.push(i)$\EndFor\State \Return $result$</code></pre><p>\EndProcedure<br>\end{algorithmic}<br>\end{algorithm}</p></div><h4 id="Java-代码实现">Java 代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.Stack;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MonotonicStack</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] nextGreaterElements(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <br>        <span class="hljs-comment">// Initialize result with -1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            result[i] = -<span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[stack.peek()] &lt; nums[i]) &#123;<br>                result[stack.pop()] = nums[i];<br>            &#125;<br>            stack.push(i);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MonotonicStack</span> <span class="hljs-variable">ms</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MonotonicStack</span>();<br>        <span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>&#125;;<br>        <span class="hljs-type">int</span>[] result = ms.nextGreaterElements(nums);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> val : result) &#123;<br>            System.out.print(val + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单调递减栈">单调递减栈</h3><p>栈中的每个元素比其下方的元素要小。每当新元素进栈时，如果栈顶元素比当前元素小或相等，则将栈顶元素出栈，直到栈顶元素大于新元素或栈为空。</p><h4 id="伪代码-2">伪代码</h4><div class="pseudocode">\begin{algorithm}\caption{Monotonic Decreasing Stack for Sliding Window Maximum}\begin{algorithmic}  \Procedure{SlidingWindowMax}{$nums, k$}    \State $deque \gets \emptyset$ \Comment{Initialize an empty deque}    \State $result \gets$ array of size $|nums| - k + 1$<pre><code class="hljs">\For&#123;$i \gets 0$ \To $|nums| - 1$&#125;  \Comment&#123;Remove elements out of window&#125;  \If&#123;$deque$ is not empty and $deque.front() \leq i - k$&#125;    \State $deque.pop\_front()$  \EndIf  \Comment&#123;Maintain decreasing order in the deque&#125;  \While&#123;$deque$ is not empty and $nums[deque.back()] &lt; nums[i]$&#125;    \State $deque.pop\_back()$  \EndWhile  \State $deque.push\_back(i)$  \Comment&#123;Store the current window maximum&#125;  \If&#123;$i \geq k - 1$&#125;    \State $result[i - k + 1] \gets nums[deque.front()]$  \EndIf\EndFor\State \Return $result$</code></pre><p>\EndProcedure<br>\end{algorithmic}<br>\end{algorithm}</p></div><h4 id="Java-代码实现-2">Java 代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.Deque;<br><span class="hljs-keyword">import</span> java.util.LinkedList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SlidingWindowMax</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n - k + <span class="hljs-number">1</span>];<br>        Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">// Remove elements not in the sliding window</span><br>            <span class="hljs-keyword">if</span> (!deque.isEmpty() &amp;&amp; deque.peekFirst() &lt; i - k + <span class="hljs-number">1</span>) &#123;<br>                deque.pollFirst();<br>            &#125;<br><br>            <span class="hljs-comment">// Remove elements smaller than the current number from the back</span><br>            <span class="hljs-keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i]) &#123;<br>                deque.pollLast();<br>            &#125;<br><br>            deque.offerLast(i);<br><br>            <span class="hljs-comment">// The front of the deque is the max element of the window</span><br>            <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) &#123;<br>                result[i - k + <span class="hljs-number">1</span>] = nums[deque.peekFirst()];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SlidingWindowMax</span> <span class="hljs-variable">swm</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SlidingWindowMax</span>();<br>        <span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>        <span class="hljs-type">int</span>[] result = swm.maxSlidingWindow(nums, k);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> val : result) &#123;<br>            System.out.print(val + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单调栈的应用">单调栈的应用</h2><ul><li><strong>下一个更大/更小元素</strong>：寻找某个元素右边（或左边）第一个比它大的/小的元素。例如，给定一个数组，可以利用单调栈找到每个元素的下一个更大元素。</li><li><strong>滑动窗口最大值</strong>：通过单调递减栈维护滑动窗口中的最大值。</li><li><strong>接雨水问题</strong>：通过单调递减栈有效地计算每个柱子之间能接多少雨水。</li><li><strong>柱状图最大矩形问题</strong>：通过单调递增栈找到每个柱子能形成的最大矩形面积。</li></ul><h2 id="单调栈的优缺点">单调栈的优缺点</h2><h3 id="优点">优点</h3><ul><li><strong>高效性</strong>：单调栈可以在很多问题中将时间复杂度降低到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，因为每个元素只会入栈和出栈一次，这对于某些问题而言极具优势。</li><li><strong>空间节省</strong>：相比于直接遍历所有可能的组合，单调栈只需要线性空间。</li></ul><h3 id="缺点">缺点</h3><ul><li><strong>适用场景有限</strong>：单调栈主要适用于需要按顺序处理的数据，且要求能够根据当前元素的信息更新数据状态。</li><li><strong>额外的空间开销</strong>：虽然相比暴力解法节省时间，但单调栈需要额外的栈空间，可能不适合内存有限的场景。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>Stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
