<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/08/25/Burrows%E2%80%93Wheeler%20Transform/"/>
    <url>/2024/08/25/Burrows%E2%80%93Wheeler%20Transform/</url>
    
    <content type="html"><![CDATA[<blockquote><p>[!info] Metadata</p><p>domain::<br>relevant::</p></blockquote><h2 id="What-is-Burrows-Wheeler-Transform-BWT"><a href="#What-is-Burrows-Wheeler-Transform-BWT" class="headerlink" title="What is Burrows-Wheeler Transform (BWT)"></a>What is Burrows-Wheeler Transform (BWT)</h2><p>The Burrowsâ€“Wheeler transform (BWT, also called block-sorting compression) rearranges a character string into runs of similar characters. This is useful for compression, since it tends to be easy to compress a string that has runs of repeated characters by techniques such as move-to-front transform and run-length encoding.<br>Burrows-Wheeler å˜æ¢ï¼ˆBWTï¼Œä¹Ÿç§°ä¸ºå—æ’åºå‹ç¼©ï¼‰å°†å­—ç¬¦ä¸²é‡æ–°æ’åˆ—æˆç›¸ä¼¼å­—ç¬¦çš„è¿ç»­åºåˆ—ã€‚è¿™å¯¹äºå‹ç¼©éå¸¸æœ‰ç”¨ï¼Œå› ä¸ºé€šè¿‡ç§»è‡³å‰ç«¯å˜æ¢å’Œæ¸¸ç¨‹ç¼–ç ç­‰æŠ€æœ¯ï¼Œå¾€å¾€å¯ä»¥è½»æ¾åœ°å‹ç¼©å…·æœ‰é‡å¤å­—ç¬¦è¿ç»­åºåˆ—çš„å­—ç¬¦ä¸²ã€‚</p><p>More importantly, the transformation isÂ <em>reversible</em>, without needing to store any additional data except the position of the first original character. The BWT is thus a â€œfreeâ€ method of improving the efficiency of text compression algorithms, costing only some extra computation.<br>æ›´é‡è¦çš„æ˜¯ï¼Œè¿™ç§è½¬æ¢æ˜¯å¯é€†çš„ï¼Œæ— éœ€å­˜å‚¨ä»»ä½•é¢å¤–çš„æ•°æ®ï¼Œé™¤äº†ç¬¬ä¸€ä¸ªåŸå§‹å­—ç¬¦çš„ä½ç½®ã€‚å› æ­¤ï¼ŒBWT æ˜¯ä¸€ç§â€œå…è´¹â€çš„æ–¹æ³•æ¥æé«˜æ–‡æœ¬å‹ç¼©ç®—æ³•çš„æ•ˆç‡ï¼Œåªéœ€è¦ä¸€äº›é¢å¤–è®¡ç®—æˆæœ¬ã€‚</p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>When a character string is transformed by the BWT, the transformation permutes the order of the characters. If the original string had several substrings that occurred often, then the transformed string will have several places where a single character is repeated multiple times in a row.<br>å½“ä¸€ä¸ªå­—ç¬¦ä¸²é€šè¿‡ BWT è¿›è¡Œè½¬æ¢æ—¶ï¼Œè¿™ä¸ªè½¬æ¢ä¼šæ”¹å˜å­—ç¬¦çš„é¡ºåºã€‚å¦‚æœåŸå§‹å­—ç¬¦ä¸²ä¸­æœ‰å¤šä¸ªç»å¸¸å‡ºç°çš„å­å­—ç¬¦ä¸²ï¼Œé‚£ä¹ˆè½¬æ¢åçš„å­—ç¬¦ä¸²ä¸­ä¼šæœ‰å¤šå¤„è¿ç»­é‡å¤å‡ºç°åŒä¸€ä¸ªå­—ç¬¦çš„æƒ…å†µã€‚</p><p>The transform is done by sorting all the <strong>circular shifts</strong> of a text in <strong>lexicographic order</strong> and by extracting the last column and the index of the original string in the set of sorted permutations of <code>S</code>.<br>é€šè¿‡æŒ‰<strong>å­—å…¸é¡ºåº</strong>å¯¹æ–‡æœ¬çš„æ‰€æœ‰<strong>å¾ªç¯ä½ç§»</strong>è¿›è¡Œæ’åºï¼Œå¹¶æå–æœ€åä¸€åˆ—å’ŒåŸå§‹å­—ç¬¦ä¸²åœ¨å·²æ’åºæ’åˆ—é›†åˆä¸­çš„ç´¢å¼•æ¥å®Œæˆå˜æ¢ã€‚</p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>![[BWT.png]]</p><h2 id="BWT-Applications"><a href="#BWT-Applications" class="headerlink" title="BWT Applications"></a>BWT Applications</h2><h3 id="Data-Compression"><a href="#Data-Compression" class="headerlink" title="Data Compression"></a>Data Compression</h3><p>BWT serves as the foundation for various compression algorithms, including the popular Burrows-Wheeler Compression (BWC) and the bzip2 utility. By exploiting redundancy and patterns in the data, BWT achieves significant compression ratios, making it indispensable in scenarios where storage or bandwidth is limited.</p><h3 id="DNA-Sequencing"><a href="#DNA-Sequencing" class="headerlink" title="DNA Sequencing"></a>DNA Sequencing</h3><p>In bioinformatics, BWT plays a pivotal role in DNA sequencing algorithms. It helps in aligning sequences, identifying similarities, and detecting mutations with high efficiency and accuracy.</p><h3 id="Pattern-Matching"><a href="#Pattern-Matching" class="headerlink" title="Pattern Matching"></a>Pattern Matching</h3><p>BWT, coupled with the FM-index, enables efficient pattern matching in large datasets. Applications range from text searching in documents to genome analysis in bioinformatics.</p>]]></content>
    
    
    
    <tags>
      
      <tag>ğŸ“ï¸/ğŸ”‹</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Boyer-Moore</title>
    <link href="/2024/08/18/Boyer-Moore/"/>
    <url>/2024/08/18/Boyer-Moore/</url>
    
    <content type="html"><![CDATA[<blockquote><p>[!info] Metadata</p><p>domain::<br>relevant::</p></blockquote><h2 id="What-is-Boyer-Moore-String-search-Algorithm"><a href="#What-is-Boyer-Moore-String-search-Algorithm" class="headerlink" title="What is Boyer-Moore String-search Algorithm"></a>What is Boyer-Moore String-search Algorithm</h2><p>In computer science, the Boyerâ€“Moore string-search algorithm is an efficient string-searching algorithm that is the standard benchmark for practical string-search literature.<br>åœ¨è®¡ç®—æœºç§‘å­¦ä¸­ï¼ŒBoyer-Moore å­—ç¬¦ä¸²æœç´¢ç®—æ³•æ˜¯ä¸€ç§é«˜æ•ˆçš„å­—ç¬¦ä¸²æœç´¢ç®—æ³•ï¼Œå®ƒæ˜¯å®é™…å­—ç¬¦ä¸²æœç´¢æ–‡çŒ®çš„æ ‡å‡†åŸºå‡†ã€‚</p><p>The algorithm preprocesses the string being searched for (the pattern), but not the string being searched in (the text). It is thus <strong>well-suited for applications in which the pattern is much shorter than the text or where it persists across multiple searches</strong>.<br>ç®—æ³•å¯¹è¢«æœç´¢çš„å­—ç¬¦ä¸²ï¼ˆæ¨¡å¼ï¼‰è¿›è¡Œé¢„å¤„ç†ï¼Œä½†ä¸å¯¹è¢«æœç´¢çš„å­—ç¬¦ä¸²ï¼ˆæ–‡æœ¬ï¼‰è¿›è¡Œé¢„å¤„ç†ã€‚å› æ­¤ï¼Œå®ƒéå¸¸é€‚ç”¨äº<strong>æ¨¡å¼æ¯”æ–‡æœ¬è¦çŸ­å¾—å¤šæˆ–åœ¨å¤šæ¬¡æœç´¢ä¸­ä¿æŒä¸å˜</strong>çš„åº”ç”¨åœºæ™¯ã€‚</p><h2 id="Definitions"><a href="#Definitions" class="headerlink" title="Definitions"></a>Definitions</h2><ul><li><code>T</code> denotes the input text to be searched. Its length is <code>n</code>.</li><li><code>P</code> denotes the string to be searched for, called the pattern. Its length is <code>m</code>.</li><li><code>S[i]</code> denotes the character at index i of string <code>S</code>, counting from 1.</li><li><code>S[i..j]</code> denotes the substring of string S starting at index <code>i</code> and ending at <code>j</code>, inclusive.</li><li>A prefix of <code>S</code> is a substring <code>S[1..i]</code> for some <code>i</code> in range <code>[1, l]</code>, where <code>l</code> is the length of <code>S</code>.</li><li>A suffix of <code>S</code> is a substring <code>S[i..l]</code> for some <code>i</code> in range <code>[1, l]</code>, where <code>l</code> is the length of <code>S</code>.</li><li>An alignment of <code>P</code> to <code>T</code> is an index <code>k</code> in <code>T</code> such that the last character of <code>P</code> is aligned with index <code>k</code> of <code>T</code>.</li><li>A match or occurrence of <code>P</code> occurs at an alignment <code>k</code> if <code>P</code> is equivalent to <code>T[(k-m+1)..k]</code>.</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">T</span><span class="hljs-params">(text)</span></span>: HERE IS A SIMPLE EXAMPLE<br><span class="hljs-function"><span class="hljs-title">P</span><span class="hljs-params">(pattern)</span></span>: EXAMPLE<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">pre</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pseudocode&quot;</span>&gt;</span><br>\begin&#123;algorithm&#125;<br>\caption&#123;Monotonic Stack for Finding the Next Greater Element&#125;<br>\begin&#123;algorithmic&#125;<br>  \Procedure&#123;NextGreaterElement&#125;&#123;$nums$&#125;<br>    \State $stack \gets \emptyset$ \Comment&#123;Initialize an empty stack&#125;<br>    \State $result \gets$ array of size $|nums|$ filled with $-1$<br>    \Comment&#123;Initialize result array with -1&#125;<br>    <br>    \For&#123;$i \gets 0$ \To $|nums| - 1$&#125;<br>      \While&#123;$stack$ is not empty and $nums[stack.top()] &lt; nums[i]$&#125;<br>        \State $index \gets stack.pop()$<br>        \State $result[index] \gets nums[i]$<br>      \EndWhile<br>      \State $stack.push(i)$<br>    \EndFor<br>    \State \Return $result$<br>  \EndProcedure<br>\end&#123;algorithmic&#125;<br>\end&#123;algorithm&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><br></code></pre></td></tr></table></figure><pre><code class="pseudocode">\begin&#123;algorithm&#125;\caption&#123;Monotonic Stack for Finding the Next Greater Element&#125;\begin&#123;algorithmic&#125;  \Procedure&#123;NextGreaterElement&#125;&#123;$nums$&#125;    \State $stack \gets \emptyset$ \Comment&#123;Initialize an empty stack&#125;    \State $result \gets$ array of size $|nums|$ filled with $-1$    \Comment&#123;Initialize result array with -1&#125;        \For&#123;$i \gets 0$ \To $|nums| - 1$&#125;      \While&#123;$stack$ is not empty and $nums[stack.top()] < nums[i]$&#125;        \State $index \gets stack.pop()$        \State $result[index] \gets nums[i]$      \EndWhile      \State $stack.push(i)$    \EndFor    \State \Return $result$  \EndProcedure\end&#123;algorithmic&#125;\end&#123;algorithm&#125;</code></pre><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>The Boyerâ€“Moore algorithm searches for occurrences of $P$ in $T$ by performing explicit character comparisons at different alignments. Instead of a brute-force search of all alignments (of which there are $n-m+1$), Boyerâ€“Moore uses information gained by preprocessing $P$ to skip as many alignments as possible.<br>Boyer-Moore ç®—æ³•é€šè¿‡åœ¨ä¸åŒçš„å¯¹é½ä½ç½®æ‰§è¡Œæ˜¾å¼å­—ç¬¦æ¯”è¾ƒæ¥æœç´¢ $T$ ä¸­ $P$ çš„å‡ºç°ã€‚è€Œä¸æ˜¯å¯¹æ‰€æœ‰å¯èƒ½çš„å¯¹é½ä½ç½®è¿›è¡Œè›®åŠ›æœç´¢ï¼ˆæ€»å…±æœ‰ $n-m+1$ ä¸ªï¼‰ï¼ŒBoyer-Moore åˆ©ç”¨é¢„å¤„ç† $P$ æ‰€å¾—åˆ°çš„ä¿¡æ¯ï¼Œå°½å¯èƒ½åœ°è·³è¿‡å¤šä½™çš„å¯¹é½ä½ç½®ã€‚</p><p>The key insight in this algorithm is that if the end of the pattern is compared to the text, then jumps along the text can be made rather than checking every character of the text. The reason that this works is that in lining up the pattern against the text, the last character of the pattern is compared to the character in the text. If the characters do not match, there is no need to continue searching backwards along the text. If the character in the text does not match any of the characters in the pattern, then the next character in the text to check is locatedÂ mÂ characters farther along the text, whereÂ mÂ is the length of the pattern. If the character in the textÂ <em>is</em>Â in the pattern, then a partial shift of the pattern along the text is done to line up along the matching character and the process is repeated. Jumping along the text to make comparisons rather than checking every character in the text decreases the number of comparisons that have to be made, which is the key to the efficiency of the algorithm.<br>è¯¥ç®—æ³•çš„å…³é”®æ´å¯Ÿæ˜¯ï¼Œå¦‚æœå°†æ¨¡å¼çš„æœ«å°¾ä¸æ–‡æœ¬è¿›è¡Œæ¯”è¾ƒï¼Œé‚£ä¹ˆå¯ä»¥è·³è¿‡æ–‡æœ¬ä¸­çš„ä¸€äº›å­—ç¬¦è€Œä¸å¿…æ£€æŸ¥æ¯ä¸ªå­—ç¬¦ã€‚è¿™æ ·åšçš„åŸå› æ˜¯ï¼Œåœ¨å°†æ¨¡å¼ä¸æ–‡æœ¬å¯¹é½æ—¶ï¼Œä¼šå°†æ¨¡å¼çš„æœ€åä¸€ä¸ªå­—ç¬¦ä¸æ–‡æœ¬ä¸­çš„å­—ç¬¦è¿›è¡Œæ¯”è¾ƒã€‚å¦‚æœå­—ç¬¦ä¸åŒ¹é…ï¼Œåˆ™æ— éœ€ç»§ç»­å‘åæœç´¢æ–‡æœ¬ã€‚å¦‚æœæ–‡æœ¬ä¸­çš„å­—ç¬¦ä¸æ¨¡å¼ä¸­ä»»ä½•ä¸€ä¸ªå­—ç¬¦éƒ½ä¸åŒ¹é…ï¼Œåˆ™éœ€è¦åœ¨æ–‡æœ¬ä¸Šå†å‘å‰ç§»åŠ¨ m ä¸ªä½ç½®æ¥æ£€æŸ¥ä¸‹ä¸€ä¸ªè¦æ¯”è¾ƒçš„å­—ç¬¦ï¼Œå…¶ä¸­ m æ˜¯æ¨¡å¼é•¿åº¦ã€‚å¦‚æœæ–‡æœ¬ä¸­çš„å­—ç¬¦åœ¨æ¨¡å¼ä¸­å­˜åœ¨ï¼Œåˆ™ä¼šå¯¹æ¨¡å¼è¿›è¡Œéƒ¨åˆ†ç§»ä½ä»¥ä½¿å…¶ä¸åŒ¹é…åˆ°çš„å­—ç¬¦å¯¹é½ï¼Œå¹¶é‡å¤æ­¤è¿‡ç¨‹ã€‚é€šè¿‡è·³è¿‡ä¸€äº›æ–‡å­—æ¥è¿›è¡Œæ¯”è¾ƒè€Œä¸æ˜¯æ£€æŸ¥æ¯ä¸ªæ–‡å­—ï¼Œå‡å°‘äº†å¿…é¡»æ‰§è¡Œçš„æ¯”è¾ƒæ¬¡æ•°ï¼Œè¿™å°±æ˜¯è¯¥ç®—æ³•é«˜æ•ˆæ€§èƒ½èƒŒåå…³é”®æ‰€åœ¨ã€‚</p><p>More formally, the algorithm begins at alignmentÂ $k&#x3D;m$, so the start ofÂ $P$Â is aligned with the start ofÂ $T$. Characters inÂ $P$Â andÂ $T$Â are then compared starting at indexÂ $m$Â inÂ $P$Â andÂ $k$Â inÂ $T$, moving backward. The strings are matched from the end ofÂ $P$Â to the start ofÂ $P$. The comparisons continue until either the beginning ofÂ $P$Â is reached (which means there is a match) or a mismatch occurs upon which the alignment is shifted forward (to the right) according to the maximum value permitted by a number of rules. The comparisons are performed again at the new alignment, and the process repeats until the alignment is shifted past the end ofÂ $T$, which means no further matches will be found.<br>æ›´æ­£å¼åœ°è¯´ï¼Œç®—æ³•ä»å¯¹é½ $k&#x3D;m$ å¼€å§‹ï¼Œå› æ­¤ $P$ çš„å¼€å¤´ä¸ $T$ çš„å¼€å¤´å¯¹é½ã€‚ç„¶åä» $P$ ä¸­çš„ç´¢å¼• $m$ å’Œ $T$ ä¸­çš„ç´¢å¼• $k$ å¼€å§‹å‘åæ¯”è¾ƒå­—ç¬¦ã€‚å­—ç¬¦ä¸²ä» $P$ çš„æœ«å°¾åˆ° $P$ çš„å¼€å¤´è¿›è¡ŒåŒ¹é…ã€‚æ¯”è¾ƒå°†ç»§ç»­ï¼Œç›´åˆ°è¾¾åˆ° $P$ çš„å¼€å¤´ï¼ˆè¡¨ç¤ºæœ‰åŒ¹é…ï¼‰æˆ–å‘ç”Ÿä¸åŒ¹é…ä¸ºæ­¢ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ ¹æ®ä¸€äº›è§„åˆ™å…è®¸çš„æœ€å¤§å€¼å‘å‰ï¼ˆå‘å³ï¼‰ç§»åŠ¨å¯¹é½ã€‚åœ¨æ–°ä½ç½®å†æ¬¡æ‰§è¡Œæ¯”è¾ƒï¼Œå¹¶é‡å¤è¯¥è¿‡ç¨‹ï¼Œç›´åˆ°å¯¹é½è¶…å‡ºäº† $T$ çš„æœ«å°¾ï¼Œè¿™æ„å‘³ç€ä¸ä¼šæ‰¾åˆ°è¿›ä¸€æ­¥çš„åŒ¹é…ã€‚</p><p>The shift rules are implemented as constant-time table lookups, using tables generated during the preprocessing ofÂ $P$.<br>å®æ–½ç§»ä½è§„åˆ™æ—¶ï¼Œä½¿ç”¨åœ¨é¢„å¤„ç† $P$ æœŸé—´ç”Ÿæˆçš„å¸¸æ•°æ—¶é—´è¡¨æŸ¥æ‰¾ã€‚</p><h2 id="Shift-Rules"><a href="#Shift-Rules" class="headerlink" title="Shift Rules"></a>Shift Rules</h2><p>A shift is calculated by applying two rules: the <strong>bad-character rule</strong> and the <strong>good-suffix rule</strong>. The actual shifting offset is the <em>maximum</em> of the shifts calculated by these rules.<br>é€šè¿‡åº”ç”¨ä¸¤ä¸ªè§„åˆ™æ¥è®¡ç®—ç§»åŠ¨åç§»é‡ï¼š<strong>åå­—ç¬¦è§„åˆ™</strong>å’Œ<strong>å¥½åç¼€è§„åˆ™</strong>ã€‚å®é™…çš„ç§»åŠ¨åç§»é‡æ˜¯ç”±è¿™äº›è§„åˆ™è®¡ç®—å‡ºçš„æœ€å¤§å€¼ã€‚</p><h3 id="The-Bad-character-Rule"><a href="#The-Bad-character-Rule" class="headerlink" title="The Bad-character Rule"></a>The Bad-character Rule</h3><h4 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h4><p>The bad-character rule considers the character inÂ $T$Â at which the comparison process failed (assuming such a failure occurred).<br>åå­—ç¬¦è§„åˆ™è€ƒè™‘äº†åœ¨æ¯”è¾ƒè¿‡ç¨‹ä¸­å¤±è´¥çš„ T ä¸­çš„å­—ç¬¦ï¼ˆå‡è®¾å‘ç”Ÿäº†è¿™æ ·çš„å¤±è´¥ï¼‰ã€‚</p><ul><li>The next occurrence of that character to the left inÂ $P$Â is found, and a shift which brings that occurrence in line with the mismatched occurrence inÂ $T$Â is proposed.<br>æ‰¾åˆ° P ä¸­è¯¥å­—ç¬¦å·¦ä¾§çš„ä¸‹ä¸€ä¸ªå‡ºç°ä½ç½®ï¼Œå¹¶æå‡ºä¸€ç§ç§»åŠ¨ï¼Œä½¿å¾—è¯¥ä½ç½®ä¸ T ä¸­ä¸åŒ¹é…çš„ä½ç½®å¯¹é½ã€‚</li><li>If the mismatched character does not occur to the left inÂ $P$, a shift is proposed that moves the entirety ofÂ $P$Â past the point of mismatch.<br>å¦‚æœä¸åŒ¹é…çš„å­—ç¬¦åœ¨ P ä¸­ä¸å­˜åœ¨å·¦ä¾§ï¼Œåˆ™æè®®è¿›è¡Œæ•´ä½“ç§»åŠ¨ï¼Œå°† P å®Œå…¨ç§»åˆ°ä¸åŒ¹é…ç‚¹ä¹‹åã€‚</li></ul><h4 id="Preprocessing"><a href="#Preprocessing" class="headerlink" title="Preprocessing"></a>Preprocessing</h4><p>Methods vary on the exact form the table for the bad-character rule should take, but a simple constant-time lookup solution is as follows: create a 2D table which is indexed first by the index of the characterÂ $c$Â in the alphabet and second by the indexÂ $i$Â in the pattern. This lookup will return the occurrence ofÂ $c$Â inÂ $P$Â with the next-highest index $j&lt;i$â Â or $-1$ if there is no such occurrence. The proposed shift will then beÂ â $i-j$â , withÂ â $O(1)$â Â lookup time andÂ â $O(km)$ space, assuming a finite alphabet of lengthÂ $k$.<br>åœ¨åå­—ç¬¦è§„åˆ™ä¸­ï¼Œè¡¨æ ¼çš„å…·ä½“å½¢å¼å¯èƒ½æœ‰æ‰€ä¸åŒï¼Œä½†ä¸€ä¸ªç®€å•çš„å¸¸æ•°æ—¶é—´æŸ¥æ‰¾è§£å†³æ–¹æ¡ˆå¦‚ä¸‹ï¼šåˆ›å»ºä¸€ä¸ªäºŒç»´è¡¨æ ¼ï¼Œé¦–å…ˆæŒ‰å­—æ¯è¡¨ä¸­å­—ç¬¦ $c$ çš„ç´¢å¼•è¿›è¡Œç´¢å¼•ï¼Œç„¶åæŒ‰æ¨¡å¼ä¸­ç´¢å¼• $i$ è¿›è¡Œç¬¬äºŒæ¬¡ç´¢å¼•ã€‚è¿™ä¸ªæŸ¥æ‰¾å°†è¿”å› $P$ ä¸­å­—ç¬¦ $c$ åœ¨ä¸‹ä¸€ä¸ªæœ€é«˜ç´¢å¼• $j&lt;i$â å¤„çš„å‡ºç°ä½ç½®ï¼Œå¦‚æœæ²¡æœ‰è¿™æ ·çš„å‡ºç°ï¼Œåˆ™è¿”å› -1ã€‚æè®®çš„ç§»åŠ¨é‡å°†æ˜¯â $i-j$â ï¼Œå…·æœ‰â  $O(1)$ â æŸ¥æ‰¾æ—¶é—´å’Œ â  $O(km)$ ç©ºé—´å¤æ‚åº¦ï¼ˆå‡è®¾å­—æ¯è¡¨é•¿åº¦ä¸º $k$ï¼‰ã€‚</p><h3 id="The-Good-suffix-Rule"><a href="#The-Good-suffix-Rule" class="headerlink" title="The Good-suffix Rule"></a>The Good-suffix Rule</h3><h4 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h4><p>The good-suffix rule is markedly more complex in both concept and implementation than the bad-character rule. Like the bad-character rule, it also exploits the algorithmâ€™s feature of comparisons beginning at the end of the pattern and proceeding towards the patternâ€™s start. It can be described as follows:<br>å¥½åç¼€è§„åˆ™åœ¨æ¦‚å¿µå’Œå®ç°ä¸Šæ¯”åå­—ç¬¦è§„åˆ™æ›´åŠ å¤æ‚ã€‚ä¸åå­—ç¬¦è§„åˆ™ç±»ä¼¼ï¼Œå®ƒä¹Ÿåˆ©ç”¨äº†ç®—æ³•ä»æ¨¡å¼çš„æœ«å°¾å¼€å§‹æ¯”è¾ƒå¹¶å‘æ¨¡å¼çš„èµ·å§‹ä½ç½®å‰è¿›çš„ç‰¹ç‚¹ã€‚å¯ä»¥æè¿°ä¸ºï¼š</p><p>Suppose for a given alignment ofÂ $P$Â andÂ $T$, a substringÂ $t$ ofÂ $T$Â matches a suffix ofÂ $P$Â and supposeÂ $t$Â is the largest such substring for the given alignment.<br>å‡è®¾å¯¹äºç»™å®šçš„ $P$ å’Œ $T$ çš„å¯¹é½ï¼Œå­—ç¬¦ä¸² $t$ æ˜¯ $T$ çš„ä¸€ä¸ªå­ä¸²ï¼Œä¸ $P$ çš„åç¼€åŒ¹é…ï¼Œå¹¶ä¸”å‡è®¾åœ¨ç»™å®šçš„å¯¹é½ä¸­ï¼Œ $t$ æ˜¯æœ€å¤§çš„è¿™æ ·å­ä¸²ã€‚</p><ol><li>Then find, if it exists, the right-most copyÂ $tâ€™$Â ofÂ $t$ inÂ $P$Â such thatÂ $t$Â is not a suffix ofÂ $P$Â and the character to the left ofÂ $tâ€™$Â inÂ $P$Â differs from the character to the left ofÂ $tâ€™$Â inÂ $P$. ShiftÂ $P$Â to the right so that substringÂ $tâ€™$Â inÂ $P$Â aligns with substringÂ $t$Â inÂ $T$.<br>ç„¶åï¼Œåœ¨ $P$ ä¸­æ‰¾åˆ°ï¼Œå¦‚æœå­˜åœ¨çš„è¯ï¼Œæœ€å³è¾¹çš„ $t$ çš„å‰¯æœ¬ $tâ€™$ï¼Œä½¿å¾— $t$ ä¸æ˜¯ $P$ çš„åç¼€ï¼Œå¹¶ä¸”åœ¨ $P$ ä¸­ä¸ $tâ€™$ å·¦è¾¹çš„å­—ç¬¦ä¸åŒã€‚å°†å­—ç¬¦ä¸² $tâ€™$ åœ¨ $P$ ä¸­å‘å³ç§»åŠ¨ï¼Œä½¿å…¶ä¸å­—ç¬¦ä¸² $t$ åœ¨ $T$ ä¸­å¯¹é½ã€‚</li><li>IfÂ $tâ€™$Â does not exist, then shift the left end ofÂ $P$Â to the right by the least amount (past the left end ofÂ $t$Â inÂ $T$) so that a prefix of the shifted pattern matches a suffix ofÂ $t$Â inÂ $T$. This includes cases whereÂ $t$Â is an exact match ofÂ $P$.<br>å¦‚æœ $tâ€™$ ä¸å­˜åœ¨ï¼Œåˆ™å°† $P$ çš„å·¦ç«¯å‘å³ç§»åŠ¨æœ€å°‘çš„é‡ï¼ˆè¶…è¿‡ $T$ ä¸­ $t$ çš„å·¦ç«¯ï¼‰ä»¥ä½¿å¾—ç§»åŠ¨åçš„æ¨¡å¼å‰ç¼€ä¸ $T$ ä¸­ $t$ çš„åç¼€åŒ¹é…ã€‚è¿™åŒ…æ‹¬äº† $t$ ä¸ $P$ å®Œå…¨åŒ¹é…çš„æƒ…å†µã€‚</li><li>If no such shift is possible, then shiftÂ $P$Â byÂ $m$Â (length of $P$) places to the right.<br>å¦‚æœæ²¡æœ‰è¿™æ ·çš„ç§»ä½å¯èƒ½ï¼Œåˆ™å°† $P$ å‘å³ç§»åŠ¨ $m$ï¼ˆ$P$ çš„é•¿åº¦ï¼‰ä¸ªä½ç½®ã€‚</li></ol><h4 id="Preprocessing-1"><a href="#Preprocessing-1" class="headerlink" title="Preprocessing"></a>Preprocessing</h4><p>The good-suffix rule requires two tables: one for use in the general case (where a copy $t^{\prime}$ is found), and another for use when the general case returns no meaningful result. These tables will be designated $L$ and $H$ respectively. Their definitions are as follows:<br>å¥½åç¼€è§„åˆ™éœ€è¦ä¸¤ä¸ªè¡¨æ ¼ï¼šä¸€ä¸ªç”¨äºä¸€èˆ¬æƒ…å†µï¼ˆå½“æ‰¾åˆ°å‰¯æœ¬ $t^{\prime}$ æ—¶ï¼‰ï¼Œå¦ä¸€ä¸ªç”¨äºä¸€èˆ¬æƒ…å†µè¿”å›æ— æ„ä¹‰ç»“æœæ—¶ä½¿ç”¨ã€‚è¿™äº›è¡¨å°†åˆ†åˆ«è¢«æŒ‡å®šä¸º $L$ å’Œ $H$ã€‚å®ƒä»¬çš„å®šä¹‰å¦‚ä¸‹ï¼š</p><ul><li>For each $i, L[i]$ is the largest position less than $m$ such that string $P[i . . m]$ matches a suffix of $P[1 . . L[i]]$ and such that the character preceding that suffix is not equal to $P[i-1] . L[i]$ is defined to be zero if there is no position satisfying the condition.<br>å¯¹äºæ¯ä¸ª $i$ï¼Œ$L[i]$ æ˜¯å°äº $m$ çš„æœ€å¤§ä½ç½®ï¼Œä½¿å¾—å­—ç¬¦ä¸² $P[i . . m]$ ä¸ $P[1 . . L[i]]$ çš„åç¼€åŒ¹é…ï¼Œå¹¶ä¸”è¯¥åç¼€å‰é¢çš„å­—ç¬¦ä¸ç­‰äº $P[i-1]$ã€‚å¦‚æœæ²¡æœ‰æ»¡è¶³æ¡ä»¶çš„ä½ç½®ï¼Œåˆ™å®šä¹‰ $L[i]$ ä¸ºé›¶ã€‚</li><li>Let $H[i]$ denote the length of the largest suffix of $P[i . . m]$ that is also a prefix of $P$, if one exists. If none exists, let $H[i]$ be zero.<br>è®© $H[i]$ è¡¨ç¤º $P[i . . m]$ çš„æœ€é•¿åç¼€ï¼Œå¦‚æœå®ƒä¹Ÿæ˜¯ $P$ çš„å‰ç¼€ã€‚å¦‚æœä¸å­˜åœ¨è¿™æ ·çš„åç¼€ï¼Œåˆ™ä»¤ $H[i]$ ä¸ºé›¶ã€‚</li></ul><p>Both of these tables are constructible in $O(m)$ time and use $O(m)$ space. The alignment shift for index $i$ in $P$ is given by $m-L[i]$ or $m-H[i]$. $H$ should only be used if $L[i]$ is zero or a match has been found.<br>è¿™ä¸¤ä¸ªè¡¨æ ¼éƒ½å¯ä»¥åœ¨ $O(m)$ çš„æ—¶é—´å†…æ„å»ºï¼Œå¹¶ä¸”ä½¿ç”¨ $O(m)$ çš„ç©ºé—´ã€‚å¯¹äº $P$ ä¸­ç´¢å¼• $i$ çš„å¯¹é½åç§»ç”± $m-L[i]$ æˆ– $m-H[i]$ ç»™å‡ºã€‚åªæœ‰å½“ $L[i]$ ä¸ºé›¶æˆ–æ‰¾åˆ°åŒ¹é…æ—¶æ‰åº”è¯¥ä½¿ç”¨ $H$ã€‚</p><h2 id="Implementations"><a href="#Implementations" class="headerlink" title="Implementations"></a>Implementations</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><br></code></pre></td></tr></table></figure><h2 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h2><ul><li><a href="https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm#Java_implementation">Boyer-Moore algorithm wikipedia</a></li><li><a href="https://cmps-people.ok.ubc.ca/ylucet/DS/BoyerMoore.html">Boyer-Moore String Search Visualisations</a></li><li><a href="https://www.cs.utexas.edu/~moore/best-ideas/string-searching/fstrpos-example.html#step7">A brilliant visualisation example</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>CS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>String</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
