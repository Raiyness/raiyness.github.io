<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/08/25/Burrows%E2%80%93Wheeler%20Transform/"/>
    <url>/2024/08/25/Burrows%E2%80%93Wheeler%20Transform/</url>
    
    <content type="html"><![CDATA[<blockquote><p>[!info] Metadata</p><p>domain::<br>relevant::</p></blockquote><h2 id="What-is-Burrows-Wheeler-Transform-BWT"><a href="#What-is-Burrows-Wheeler-Transform-BWT" class="headerlink" title="What is Burrows-Wheeler Transform (BWT)"></a>What is Burrows-Wheeler Transform (BWT)</h2><p>The Burrows–Wheeler transform (BWT, also called block-sorting compression) rearranges a character string into runs of similar characters. This is useful for compression, since it tends to be easy to compress a string that has runs of repeated characters by techniques such as move-to-front transform and run-length encoding.<br>Burrows-Wheeler 变换（BWT，也称为块排序压缩）将字符串重新排列成相似字符的连续序列。这对于压缩非常有用，因为通过移至前端变换和游程编码等技术，往往可以轻松地压缩具有重复字符连续序列的字符串。</p><p>More importantly, the transformation is <em>reversible</em>, without needing to store any additional data except the position of the first original character. The BWT is thus a “free” method of improving the efficiency of text compression algorithms, costing only some extra computation.<br>更重要的是，这种转换是可逆的，无需存储任何额外的数据，除了第一个原始字符的位置。因此，BWT 是一种“免费”的方法来提高文本压缩算法的效率，只需要一些额外计算成本。</p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>When a character string is transformed by the BWT, the transformation permutes the order of the characters. If the original string had several substrings that occurred often, then the transformed string will have several places where a single character is repeated multiple times in a row.<br>当一个字符串通过 BWT 进行转换时，这个转换会改变字符的顺序。如果原始字符串中有多个经常出现的子字符串，那么转换后的字符串中会有多处连续重复出现同一个字符的情况。</p><p>The transform is done by sorting all the <strong>circular shifts</strong> of a text in <strong>lexicographic order</strong> and by extracting the last column and the index of the original string in the set of sorted permutations of <code>S</code>.<br>通过按<strong>字典顺序</strong>对文本的所有<strong>循环位移</strong>进行排序，并提取最后一列和原始字符串在已排序排列集合中的索引来完成变换。</p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>![[BWT.png]]</p><h2 id="BWT-Applications"><a href="#BWT-Applications" class="headerlink" title="BWT Applications"></a>BWT Applications</h2><h3 id="Data-Compression"><a href="#Data-Compression" class="headerlink" title="Data Compression"></a>Data Compression</h3><p>BWT serves as the foundation for various compression algorithms, including the popular Burrows-Wheeler Compression (BWC) and the bzip2 utility. By exploiting redundancy and patterns in the data, BWT achieves significant compression ratios, making it indispensable in scenarios where storage or bandwidth is limited.</p><h3 id="DNA-Sequencing"><a href="#DNA-Sequencing" class="headerlink" title="DNA Sequencing"></a>DNA Sequencing</h3><p>In bioinformatics, BWT plays a pivotal role in DNA sequencing algorithms. It helps in aligning sequences, identifying similarities, and detecting mutations with high efficiency and accuracy.</p><h3 id="Pattern-Matching"><a href="#Pattern-Matching" class="headerlink" title="Pattern Matching"></a>Pattern Matching</h3><p>BWT, coupled with the FM-index, enables efficient pattern matching in large datasets. Applications range from text searching in documents to genome analysis in bioinformatics.</p>]]></content>
    
    
    
    <tags>
      
      <tag>📝️/🔋</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Boyer-Moore</title>
    <link href="/2024/08/18/Boyer-Moore/"/>
    <url>/2024/08/18/Boyer-Moore/</url>
    
    <content type="html"><![CDATA[<blockquote><p>[!info] Metadata</p><p>domain::<br>relevant::</p></blockquote><h2 id="What-is-Boyer-Moore-String-search-Algorithm"><a href="#What-is-Boyer-Moore-String-search-Algorithm" class="headerlink" title="What is Boyer-Moore String-search Algorithm"></a>What is Boyer-Moore String-search Algorithm</h2><p>In computer science, the Boyer–Moore string-search algorithm is an efficient string-searching algorithm that is the standard benchmark for practical string-search literature.<br>在计算机科学中，Boyer-Moore 字符串搜索算法是一种高效的字符串搜索算法，它是实际字符串搜索文献的标准基准。</p><p>The algorithm preprocesses the string being searched for (the pattern), but not the string being searched in (the text). It is thus <strong>well-suited for applications in which the pattern is much shorter than the text or where it persists across multiple searches</strong>.<br>算法对被搜索的字符串（模式）进行预处理，但不对被搜索的字符串（文本）进行预处理。因此，它非常适用于<strong>模式比文本要短得多或在多次搜索中保持不变</strong>的应用场景。</p><h2 id="Definitions"><a href="#Definitions" class="headerlink" title="Definitions"></a>Definitions</h2><ul><li><code>T</code> denotes the input text to be searched. Its length is <code>n</code>.</li><li><code>P</code> denotes the string to be searched for, called the pattern. Its length is <code>m</code>.</li><li><code>S[i]</code> denotes the character at index i of string <code>S</code>, counting from 1.</li><li><code>S[i..j]</code> denotes the substring of string S starting at index <code>i</code> and ending at <code>j</code>, inclusive.</li><li>A prefix of <code>S</code> is a substring <code>S[1..i]</code> for some <code>i</code> in range <code>[1, l]</code>, where <code>l</code> is the length of <code>S</code>.</li><li>A suffix of <code>S</code> is a substring <code>S[i..l]</code> for some <code>i</code> in range <code>[1, l]</code>, where <code>l</code> is the length of <code>S</code>.</li><li>An alignment of <code>P</code> to <code>T</code> is an index <code>k</code> in <code>T</code> such that the last character of <code>P</code> is aligned with index <code>k</code> of <code>T</code>.</li><li>A match or occurrence of <code>P</code> occurs at an alignment <code>k</code> if <code>P</code> is equivalent to <code>T[(k-m+1)..k]</code>.</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">T</span><span class="hljs-params">(text)</span></span>: HERE IS A SIMPLE EXAMPLE<br><span class="hljs-function"><span class="hljs-title">P</span><span class="hljs-params">(pattern)</span></span>: EXAMPLE<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">pre</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pseudocode&quot;</span>&gt;</span><br>\begin&#123;algorithm&#125;<br>\caption&#123;Monotonic Stack for Finding the Next Greater Element&#125;<br>\begin&#123;algorithmic&#125;<br>  \Procedure&#123;NextGreaterElement&#125;&#123;$nums$&#125;<br>    \State $stack \gets \emptyset$ \Comment&#123;Initialize an empty stack&#125;<br>    \State $result \gets$ array of size $|nums|$ filled with $-1$<br>    \Comment&#123;Initialize result array with -1&#125;<br>    <br>    \For&#123;$i \gets 0$ \To $|nums| - 1$&#125;<br>      \While&#123;$stack$ is not empty and $nums[stack.top()] &lt; nums[i]$&#125;<br>        \State $index \gets stack.pop()$<br>        \State $result[index] \gets nums[i]$<br>      \EndWhile<br>      \State $stack.push(i)$<br>    \EndFor<br>    \State \Return $result$<br>  \EndProcedure<br>\end&#123;algorithmic&#125;<br>\end&#123;algorithm&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><br></code></pre></td></tr></table></figure><pre><code class="pseudocode">\begin&#123;algorithm&#125;\caption&#123;Monotonic Stack for Finding the Next Greater Element&#125;\begin&#123;algorithmic&#125;  \Procedure&#123;NextGreaterElement&#125;&#123;$nums$&#125;    \State $stack \gets \emptyset$ \Comment&#123;Initialize an empty stack&#125;    \State $result \gets$ array of size $|nums|$ filled with $-1$    \Comment&#123;Initialize result array with -1&#125;        \For&#123;$i \gets 0$ \To $|nums| - 1$&#125;      \While&#123;$stack$ is not empty and $nums[stack.top()] < nums[i]$&#125;        \State $index \gets stack.pop()$        \State $result[index] \gets nums[i]$      \EndWhile      \State $stack.push(i)$    \EndFor    \State \Return $result$  \EndProcedure\end&#123;algorithmic&#125;\end&#123;algorithm&#125;</code></pre><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>The Boyer–Moore algorithm searches for occurrences of $P$ in $T$ by performing explicit character comparisons at different alignments. Instead of a brute-force search of all alignments (of which there are $n-m+1$), Boyer–Moore uses information gained by preprocessing $P$ to skip as many alignments as possible.<br>Boyer-Moore 算法通过在不同的对齐位置执行显式字符比较来搜索 $T$ 中 $P$ 的出现。而不是对所有可能的对齐位置进行蛮力搜索（总共有 $n-m+1$ 个），Boyer-Moore 利用预处理 $P$ 所得到的信息，尽可能地跳过多余的对齐位置。</p><p>The key insight in this algorithm is that if the end of the pattern is compared to the text, then jumps along the text can be made rather than checking every character of the text. The reason that this works is that in lining up the pattern against the text, the last character of the pattern is compared to the character in the text. If the characters do not match, there is no need to continue searching backwards along the text. If the character in the text does not match any of the characters in the pattern, then the next character in the text to check is located m characters farther along the text, where m is the length of the pattern. If the character in the text <em>is</em> in the pattern, then a partial shift of the pattern along the text is done to line up along the matching character and the process is repeated. Jumping along the text to make comparisons rather than checking every character in the text decreases the number of comparisons that have to be made, which is the key to the efficiency of the algorithm.<br>该算法的关键洞察是，如果将模式的末尾与文本进行比较，那么可以跳过文本中的一些字符而不必检查每个字符。这样做的原因是，在将模式与文本对齐时，会将模式的最后一个字符与文本中的字符进行比较。如果字符不匹配，则无需继续向后搜索文本。如果文本中的字符与模式中任何一个字符都不匹配，则需要在文本上再向前移动 m 个位置来检查下一个要比较的字符，其中 m 是模式长度。如果文本中的字符在模式中存在，则会对模式进行部分移位以使其与匹配到的字符对齐，并重复此过程。通过跳过一些文字来进行比较而不是检查每个文字，减少了必须执行的比较次数，这就是该算法高效性能背后关键所在。</p><p>More formally, the algorithm begins at alignment $k&#x3D;m$, so the start of $P$ is aligned with the start of $T$. Characters in $P$ and $T$ are then compared starting at index $m$ in $P$ and $k$ in $T$, moving backward. The strings are matched from the end of $P$ to the start of $P$. The comparisons continue until either the beginning of $P$ is reached (which means there is a match) or a mismatch occurs upon which the alignment is shifted forward (to the right) according to the maximum value permitted by a number of rules. The comparisons are performed again at the new alignment, and the process repeats until the alignment is shifted past the end of $T$, which means no further matches will be found.<br>更正式地说，算法从对齐 $k&#x3D;m$ 开始，因此 $P$ 的开头与 $T$ 的开头对齐。然后从 $P$ 中的索引 $m$ 和 $T$ 中的索引 $k$ 开始向后比较字符。字符串从 $P$ 的末尾到 $P$ 的开头进行匹配。比较将继续，直到达到 $P$ 的开头（表示有匹配）或发生不匹配为止，在这种情况下，根据一些规则允许的最大值向前（向右）移动对齐。在新位置再次执行比较，并重复该过程，直到对齐超出了 $T$ 的末尾，这意味着不会找到进一步的匹配。</p><p>The shift rules are implemented as constant-time table lookups, using tables generated during the preprocessing of $P$.<br>实施移位规则时，使用在预处理 $P$ 期间生成的常数时间表查找。</p><h2 id="Shift-Rules"><a href="#Shift-Rules" class="headerlink" title="Shift Rules"></a>Shift Rules</h2><p>A shift is calculated by applying two rules: the <strong>bad-character rule</strong> and the <strong>good-suffix rule</strong>. The actual shifting offset is the <em>maximum</em> of the shifts calculated by these rules.<br>通过应用两个规则来计算移动偏移量：<strong>坏字符规则</strong>和<strong>好后缀规则</strong>。实际的移动偏移量是由这些规则计算出的最大值。</p><h3 id="The-Bad-character-Rule"><a href="#The-Bad-character-Rule" class="headerlink" title="The Bad-character Rule"></a>The Bad-character Rule</h3><h4 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h4><p>The bad-character rule considers the character in $T$ at which the comparison process failed (assuming such a failure occurred).<br>坏字符规则考虑了在比较过程中失败的 T 中的字符（假设发生了这样的失败）。</p><ul><li>The next occurrence of that character to the left in $P$ is found, and a shift which brings that occurrence in line with the mismatched occurrence in $T$ is proposed.<br>找到 P 中该字符左侧的下一个出现位置，并提出一种移动，使得该位置与 T 中不匹配的位置对齐。</li><li>If the mismatched character does not occur to the left in $P$, a shift is proposed that moves the entirety of $P$ past the point of mismatch.<br>如果不匹配的字符在 P 中不存在左侧，则提议进行整体移动，将 P 完全移到不匹配点之后。</li></ul><h4 id="Preprocessing"><a href="#Preprocessing" class="headerlink" title="Preprocessing"></a>Preprocessing</h4><p>Methods vary on the exact form the table for the bad-character rule should take, but a simple constant-time lookup solution is as follows: create a 2D table which is indexed first by the index of the character $c$ in the alphabet and second by the index $i$ in the pattern. This lookup will return the occurrence of $c$ in $P$ with the next-highest index $j&lt;i$⁠ or $-1$ if there is no such occurrence. The proposed shift will then be ⁠$i-j$⁠, with ⁠$O(1)$⁠ lookup time and ⁠$O(km)$ space, assuming a finite alphabet of length $k$.<br>在坏字符规则中，表格的具体形式可能有所不同，但一个简单的常数时间查找解决方案如下：创建一个二维表格，首先按字母表中字符 $c$ 的索引进行索引，然后按模式中索引 $i$ 进行第二次索引。这个查找将返回 $P$ 中字符 $c$ 在下一个最高索引 $j&lt;i$⁠处的出现位置，如果没有这样的出现，则返回 -1。提议的移动量将是⁠$i-j$⁠，具有⁠ $O(1)$ ⁠查找时间和 ⁠ $O(km)$ 空间复杂度（假设字母表长度为 $k$）。</p><h3 id="The-Good-suffix-Rule"><a href="#The-Good-suffix-Rule" class="headerlink" title="The Good-suffix Rule"></a>The Good-suffix Rule</h3><h4 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h4><p>The good-suffix rule is markedly more complex in both concept and implementation than the bad-character rule. Like the bad-character rule, it also exploits the algorithm’s feature of comparisons beginning at the end of the pattern and proceeding towards the pattern’s start. It can be described as follows:<br>好后缀规则在概念和实现上比坏字符规则更加复杂。与坏字符规则类似，它也利用了算法从模式的末尾开始比较并向模式的起始位置前进的特点。可以描述为：</p><p>Suppose for a given alignment of $P$ and $T$, a substring $t$ of $T$ matches a suffix of $P$ and suppose $t$ is the largest such substring for the given alignment.<br>假设对于给定的 $P$ 和 $T$ 的对齐，字符串 $t$ 是 $T$ 的一个子串，与 $P$ 的后缀匹配，并且假设在给定的对齐中， $t$ 是最大的这样子串。</p><ol><li>Then find, if it exists, the right-most copy $t’$ of $t$ in $P$ such that $t$ is not a suffix of $P$ and the character to the left of $t’$ in $P$ differs from the character to the left of $t’$ in $P$. Shift $P$ to the right so that substring $t’$ in $P$ aligns with substring $t$ in $T$.<br>然后，在 $P$ 中找到，如果存在的话，最右边的 $t$ 的副本 $t’$，使得 $t$ 不是 $P$ 的后缀，并且在 $P$ 中与 $t’$ 左边的字符不同。将字符串 $t’$ 在 $P$ 中向右移动，使其与字符串 $t$ 在 $T$ 中对齐。</li><li>If $t’$ does not exist, then shift the left end of $P$ to the right by the least amount (past the left end of $t$ in $T$) so that a prefix of the shifted pattern matches a suffix of $t$ in $T$. This includes cases where $t$ is an exact match of $P$.<br>如果 $t’$ 不存在，则将 $P$ 的左端向右移动最少的量（超过 $T$ 中 $t$ 的左端）以使得移动后的模式前缀与 $T$ 中 $t$ 的后缀匹配。这包括了 $t$ 与 $P$ 完全匹配的情况。</li><li>If no such shift is possible, then shift $P$ by $m$ (length of $P$) places to the right.<br>如果没有这样的移位可能，则将 $P$ 向右移动 $m$（$P$ 的长度）个位置。</li></ol><h4 id="Preprocessing-1"><a href="#Preprocessing-1" class="headerlink" title="Preprocessing"></a>Preprocessing</h4><p>The good-suffix rule requires two tables: one for use in the general case (where a copy $t^{\prime}$ is found), and another for use when the general case returns no meaningful result. These tables will be designated $L$ and $H$ respectively. Their definitions are as follows:<br>好后缀规则需要两个表格：一个用于一般情况（当找到副本 $t^{\prime}$ 时），另一个用于一般情况返回无意义结果时使用。这些表将分别被指定为 $L$ 和 $H$。它们的定义如下：</p><ul><li>For each $i, L[i]$ is the largest position less than $m$ such that string $P[i . . m]$ matches a suffix of $P[1 . . L[i]]$ and such that the character preceding that suffix is not equal to $P[i-1] . L[i]$ is defined to be zero if there is no position satisfying the condition.<br>对于每个 $i$，$L[i]$ 是小于 $m$ 的最大位置，使得字符串 $P[i . . m]$ 与 $P[1 . . L[i]]$ 的后缀匹配，并且该后缀前面的字符不等于 $P[i-1]$。如果没有满足条件的位置，则定义 $L[i]$ 为零。</li><li>Let $H[i]$ denote the length of the largest suffix of $P[i . . m]$ that is also a prefix of $P$, if one exists. If none exists, let $H[i]$ be zero.<br>让 $H[i]$ 表示 $P[i . . m]$ 的最长后缀，如果它也是 $P$ 的前缀。如果不存在这样的后缀，则令 $H[i]$ 为零。</li></ul><p>Both of these tables are constructible in $O(m)$ time and use $O(m)$ space. The alignment shift for index $i$ in $P$ is given by $m-L[i]$ or $m-H[i]$. $H$ should only be used if $L[i]$ is zero or a match has been found.<br>这两个表格都可以在 $O(m)$ 的时间内构建，并且使用 $O(m)$ 的空间。对于 $P$ 中索引 $i$ 的对齐偏移由 $m-L[i]$ 或 $m-H[i]$ 给出。只有当 $L[i]$ 为零或找到匹配时才应该使用 $H$。</p><h2 id="Implementations"><a href="#Implementations" class="headerlink" title="Implementations"></a>Implementations</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><br></code></pre></td></tr></table></figure><h2 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h2><ul><li><a href="https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm#Java_implementation">Boyer-Moore algorithm wikipedia</a></li><li><a href="https://cmps-people.ok.ubc.ca/ylucet/DS/BoyerMoore.html">Boyer-Moore String Search Visualisations</a></li><li><a href="https://www.cs.utexas.edu/~moore/best-ideas/string-searching/fstrpos-example.html#step7">A brilliant visualisation example</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>CS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>String</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
